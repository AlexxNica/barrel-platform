<?xml version="1.0"?><html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<title>Module eqc_group_commands</title>
<link rel="stylesheet" type="text/css" href="stylesheet.css" title="EDoc"/>
</head>
<body bgcolor="white">
<div class="navbar"><a name="#navbar_top"/><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"/></a></td></tr></table></div>
<hr/>

<h1>Module eqc_group_commands</h1>
<ul class="index"><li><a href="#description">Description</a></li></ul>This module defines a parse transformation to enable the  
precondition, postcondition, and so on, of each command in a  
QuickCheck state machine to be specified together.
<p>Copyright Â© Quviq AB, 2012-2017</p>

<p><b>Version:</b> 1.41.2</p>

<h2><a name="description">Description</a></h2><p>This module defines a parse transformation to enable the  
precondition, postcondition, and so on, of each command in a  
QuickCheck state machine to be specified together.</p>
 
  <p>This parse transformation is used with QuickCheck state machines to  
enable specifications to be written in a different style, the  
"grouped" style. This may result in shorter,  
more readable specifications in certain cases. However, one should be warned that  
the parse transformation may cause some difficulty in debugging such  
specifications, because the compiled code no longer corresponds  
exactly to the source code.</p>
 
  <p>What the parse transformation does is to offer a new set of call-back functions to
  define QuickCheck state machines with. This parse transformation is automatically
  invoked by <tt>eqc_statem.hrl</tt>, and recognizes a grouped specification by the absence of a
  <b>command/1</b> function in the module, or by the optional user annotation
  <tt>
  -eqc_group_commands(true).
  </tt></p>
 
  <p>Note that you cannot mix the old call-back functions with the new call-back functions.  
Either you use the grouped style, or you use the call-backs as defined in the original QuickCheck  
state machine descriptions.</p>
 
  <h2>eqc_statem</h2><p>
  In the ungrouped style, an <tt>eqc_statem</tt> specification
  defines a number of callbacks, <tt>command</tt>,
  <tt>precondition</tt>, <tt>postcondition</tt>, etc, in which all
  generated commands are handled. In the default grouped style,
  each command is specified by a number of functions, which can be grouped together, that
  represent generation, precondition, postcondition, etc. These
  functions are named by appending a suffix to the name of the
  command itself.  Apart from the
  <tt>COMMAND_args</tt> call-back, each of these call-backs is optional, and
  if not provided a <b>default</b> is used.</p>
 
  <h2>eqc_component</h2>
 
  <p>In addition to the suffixes defined for <a href="eqc_statem.html"><code>eqc_statem</code></a>, a component command may
  also use any of the additional suffixes <tt>_callouts</tt> and <tt>_callers</tt>.</p>
 
  <ul>
  <li><h3>_callers/0</h3><p>
  <tt>COMMAND_callers() :: [atom()]</tt></p>
 
  <p>Returns a list of allowed callers for the <tt>COMMAND</tt>. This information is only
  used when the component is part of a cluster. If there are no restrictions for the
  command, <tt>[anyone]</tt> (the default) can be used. If used in a cluster, during
  command generation, this command is excluded from generation unless there is at least
  one caller in the list of callers that is <b>not</b> in the cluster!</p>
 
  <b>default</b>: <tt>[anyone]</tt> </li>
 
  <li><h3>_callouts/2</h3><p>
  <tt>COMMAND_callouts(S::<a href="eqc_statem.html#type-symbolic_state">symbolic_state()</a>, Args::[term()]) :: <a href="eqc_component.html#type-callout"><code>eqc_component:callout()</code></a></tt></p>
 
  <p>Returns a callout specification for the given symbolic state and the given command
  arguments. See <a href="eqc_component.html"><code>eqc_component</code></a> for details.</p>
 
 
  </li>
  </ul>
 
  <h2>eqc_fsm</h2><p>
  In the ungrouped style, an <tt>eqc_fsm</tt> specification
  defines a number of callbacks, <tt>command</tt>,
  <tt>precondition</tt>, <tt>postcondition</tt>, etc, in which all
  generated commands are handled. In the grouped style,
  each command is specified by a number of functions, which can be grouped together, that
  represent generation, precondition, postcondition, etc. These
  functions are named by appending a suffix to the name of the
  command itself.  Apart from the
  <tt>COMMAND_args</tt> callback, each of these callbacks is optional, and
  if not provided a <b>default</b> is used.</p>
 
  Note that the state transition function is specified differently for grouped style <tt>eqc_fsm</tt>
  specifications. The state names are still represented as atoms, or tuples for parameterized states,
  but the transitions no longer are a list with state names and call tuples, but with state names and
  transition function atoms instead. This also implies that one no longer provides the state data
  as argument of the transition function.
  As an example, in the ungrouped style we would write a state transition like:
  <pre>
  unlocked(S) -&gt;
    [{unlocked,{call,locker,read,[]}},
     {locked,  {call,locker,lock,[]}}].</pre>
  In grouped style, we would instead write:
  <pre>
  unlocked() -&gt;
    [{unlocked,read},
     {locked,  lock}].</pre><p>
  From the name of the functions <tt>read</tt> and <tt>lock</tt> the grouped <tt>eqc_fsm</tt> can
  derive that the functions <tt>read_args</tt> and <tt>write_args</tt> whould be invoked to obtain the  
state data generators.</p>
 
 <hr/>

<div class="navbar"><a name="#navbar_bottom"/><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"/></a></td></tr></table></div>
<p><i>Generated by EDoc, Jun 13 2017, 10:20:29.</i></p>
</body>
</html>
