<?xml version="1.0"?><html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<title>Module eqc_statem</title>
<link rel="stylesheet" type="text/css" href="stylesheet.css" title="EDoc"/>
</head>
<body bgcolor="white">
<div class="navbar"><a name="#navbar_top"/><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"/></a></td></tr></table></div>
<hr/>

<h1>Module eqc_statem</h1>
<ul class="index"><li><a href="#description">Description</a></li><li><a href="#types">Data Types</a></li><li><a href="#index">Function Index</a></li><li><a href="#functions">Function Details</a></li></ul>This module provides functions for testing operations with side-effects,  
which are specified via an abstract state machine.
<p>Copyright Â© Quviq AB, 2004-2017</p>

<p><b>Version:</b> 1.41.2</p>

<h2><a name="description">Description</a></h2><p>This module provides functions for testing operations with side-effects,  
which are specified via an abstract state machine. The state machine is in turn  
specified by a client module (which implements the callbacks for eqc_statem).  
Given such a client, this module can generate and run command sequences, checking that  
all postconditions are satisfied, and shrinking failing sequences by discarding  
commands which do not contribute to the failure. Thus it can be used to find  
minimal command sequences which elicit an unexpected behaviour.</p>
 
  <p>
  It can also generate parallel test cases from the same client
  module, which are used to test for race conditions.
  </p>
  <p>
  Modules which use this one should
  <tt>-include_lib("eqc/include/eqc_statem")</tt> to import the
  functions that <tt>eqc_statem</tt> provides.
  </p>
  <p>
  Since release 1.35 of QuickCheck, the documentation of this module has been updated to
  the grouped style of writing callbacks. In case you are confronted with a legacy state
  machine model that you need to understand, please read
  <a href="eqc_statem-1.34.html">the old documentation</a>.
  </p>
  <h3>Symbolic Commands</h3>
  Generated test cases are lists of symbolic commands (<a href="#type-command"><code>command()</code></a>), each
  of which binds a symbolic variable to the result of a symbolic function call (except,
  possibly, for a first command which initializes the <i>state</i>, see below).
  For example,
  <pre>{set, {var, 1}, {call, erlang, whereis, [a]}}</pre>
  is a command to set variable 1 to the result of calling <tt>erlang:whereis(a)</tt>.
  The command generator is specified by <tt>COMMAND_command/1</tt>.
  QuickCheck recognizes a set of suffices, such as <tt>_command</tt> to enable
  compact model notations.
  For the above symbolic call, one would write the generator:
  <pre>
  whereis_command(_S) -&gt;
    {call, erlang, whereis, [elements([a, b, c, d])]}.
  </pre>
  Alternatively, one only specifies the argument generator, which in practice
  works best, and write a wrapper for the function under test, for example:
  <pre>
  register_args(S) -&gt;
    [elements([a, b, c, d]), pid(S)].
 
  register(Name, Pid) -&gt;
    catch erlang:register(Name, Pid).
  </pre>
  When a test case is run, then symbolic variables (<a href="#type-var"><code>var()</code></a>) are replaced
  by the values they were set to, and symbolic calls (<a href="#type-call"><code>call()</code></a>) are
  performed. In addition, the post-condition of each command is checked. Running
  a list of commands generates a result which indicates whether
  any post-condition failed, or any command raised an exception, or whether all
  commands and checks completed successfully.
  <p>
  It is very important to keep in mind the difference between <i>symbolic</i>
  calls and variables, which are used during test case generation, and the
  values they represent, which are computed during test execution. We refer to
  the latter as <i>dynamic</i> values. The reason we use
  symbolic representations (rather than just working with their dynamic values)
  is to enable us to display, save, analyze,
  and above all simplify test cases before they are run.
  </p>
  <h3>States</h3>
  The client module defines an initial state in which test cases begin, and how each
  command changes that state. For example, if test cases spawn a number of processes,
  then the state might be a list of the pids that have been spawned. The state is
  used both during test case <i>generation</i> and during test <i>execution</i>.
  Obviously, at generation time the actual values returned by commands are not
  known--they must be represented symbolically. Thus during test
  generation a <i>symbolic state</i> is constructed---in this case the state might be
  a list of all earlier spawned processes:
  <pre>[{var, 1}, {var, 2}, {var, 3}]</pre>
  if the first three commands all spawned processes.
  The model for spawning process needs to update the state, for which the <tt>_next</tt>
  suffix is used: to compute the nest model state.
  <pre>
  spawn_args(_S) -&gt; [].
 
  spawn() -&gt;
    erlang:spawn(timer, sleep, [5000]).
 
  spawn_next(S, Res, []) -&gt;
    S#state{pids = S#state.pids ++ [Res]}.
  </pre>
  During test execution the
  corresponding <i>dynamic state</i> is computed--in this case a list of three
  pids returned by the first three commands in the test case. Dynamic states always
  have the same structure as the corresponding symbolic states--the difference is
  just that symbolic variables and calls are replaced by their values.
  <p>
  Symbolic states are
  used to generate symbolic commands, or to decide whether a given symbolic command
  can be included in a test case. Dynamic states are used to check postconditions.
  </p>
  <p>It is not usually necessary to track <i>all</i> relevant state information in
  the test case state--there is no need to include more information in the state
  than is necessary to generate and execute the command sequences we are interested in.</p>
 
  <h3>Callback Functions</h3>
  Each command (or API function of the software under test)
  is specified by a number of functions, which can be grouped together, that
  represent generation, precondition, postcondition, state update, etc. These
  functions are named by appending a suffix to the name of the
  command itself.  Apart from the
  <tt>COMMAND_args</tt> callback, each of these callbacks is optional, and
  if not provided a <b>default</b> is used. In addition to callbacks for
  a specific command, there are also a number of general callbacks, such as
  <ul>
  <li> <h3>initial_state/0</h3>
  <tt>initial_state() :: <a href="#type-symbolic_state"><code>symbolic_state()</code></a></tt>.
  <p>Returns the state in which each test case starts (unless a different initial
  state is supplied explicitly). This symbolic state is evaluated to
  construct the initial dynamic state before each test case is executed.</p>
  </li>
  </ul><p>  
The following call-back suffixes are provided for eqc_statem.</p>
 
  <ul>
  <li> <h3>_pre/1</h3>
  <tt>COMMAND_pre(S::<a href="#type-symbolic_state"><code>symbolic_state()</code></a>) :: bool()</tt>
  <p>Returns <tt>true</tt> if the command <tt>COMMAND</tt> may be generated in state <tt>S</tt>.
  The precondition is also used when shrinking to make sure that invalid commands
  do not pop-up in a test case while shrinking.</p>
  <b>default</b>: true
  </li>
  <li> <h3>_pre/2</h3>
  <tt>COMMAND_pre(S::<a href="#type-symbolic_state"><code>symbolic_state()</code></a>, Args::[term()]) :: bool()</tt>
  <p>Returns <tt>true</tt> if the symbolic call <tt>{call, _, COMMAND, Args}</tt> can be performed in the
  state <tt>S</tt>. The precondition is also used when shrinking to make sure that invalid commands
  do not pop-up in a test case while shrinking.</p><p>
  <b>default</b>: true</p>
 
  <p>Preconditions are used to decide whether or not to include
  candidate commands in test cases, which is why only the <i>symbolic</i> state
  information is available when preconditions are checked.</p>
  </li>
 
  <li> <h3>_pre/3</h3>
  <tt>COMMAND_pre(S::<a href="#type-symbolic_state"><code>symbolic_state()</code></a>, Args::[term()], MetaData::[proplists:property()]) :: bool()</tt>
  <p>Returns <tt>true</tt> if the symbolic call <tt>{call, _, COMMAND, Args}</tt> can be performed in the
  state <tt>S</tt> and with the given <tt>MetaData</tt>. The precondition is also used
  when shrinking to make sure that invalid commands do not pop-up in a test case while
  shrinking.</p><p>
  <b>default</b>: true</p>
 
  Note: You may only use either <tt>COMMAND_pre/2</tt> <b>or</b>
  <tt>COMMAND_pre/3</tt>, not both!
  The use of MetaData is advanced and we recommend the usage of it to experts only.
  </li>
 
  <li><h3>_adapt/2</h3>
  <tt>COMMAND_adapt(S::<a href="#type-symbolic_state"><code>symbolic_state()</code></a>, Args::[term()]) :: false | gen(<a href="#type-call"><code>call()</code></a> | [term()])</tt>
  <p> This is an <i>optional</i> call-back used during
  shrinking; when a precondition does not hold, adapt is called to try to repair/patch a
  call before it is discarded. It should return a generator for a new <a href="#type-call"><code>call()</code></a> (optionally including metadata), or just a new argument list if
  nothing else needs adapting.
  After adapt is finished, the precondition is checked again to see whether the changes were sufficient.</p>
  <b>default</b>: false
  </li>
 
  <li> <h3>_args/1</h3>
  <tt>COMMAND_args(S::<a href="#type-symbolic_state"><code>symbolic_state()</code></a>) :: gen([term()])</tt>
  <p>Generates appropriate arguments for the function under test. The result are arguments Args that are used in
  the symbolic call
  <pre>{call, ?MODULE, COMMAND, Args}</pre> in the test case generator, given that <tt>COMMAND_pre(S)</tt>
  returns true for the symbolic state <tt>S</tt> at generation time.</p>
  </li>
 
  <li> <h3>_command/1</h3>
  <tt>COMMAND_command(S::<a href="#type-symbolic_state"><code>symbolic_state()</code></a>) :: gen(<a href="#type-call"><code>call()</code></a>)</tt>
  <p>Generates an appropriate call for the function under test. The result is a symbolic
  call used in the test case generator, given that <tt>COMMAND_pre(S)</tt> returns true
  for the symbolic state <tt>S</tt> at generation time.</p>
  </li>
 
  Note: You can only use either <tt>_args</tt> or <tt>_command</tt> for a given
  <tt>COMMAND</tt>. However, you may mix <tt>_args</tt> and <tt>_command</tt> for
  different commands in a specification.
 
  <li> <h3>{no_suffix}/N</h3>
  <tt>COMMAND(...) :: term()</tt>
  <p>This is the function that is called during test case execution.</p>
  </li>
 
  <li><h3>_next/3</h3>
  <tt>COMMAND_next(S::<a href="#type-symbolic_state"><code>symbolic_state()</code></a>, V::<a href="#type-var"><code>var()</code></a>, Args::[term()]) :: <a href="#type-symbolic_state"><code>symbolic_state()</code></a></tt>
  <p>This is the state transition function of the abstract state machine,
  and it is used during <i>both</i> test generation and test
  execution. The type above refers to calls during test generation.</p>
  <p>In this case, it computes the symbolic state after symbolic
  call <tt>{call, _, COMMAND, Args}</tt>, performed in
  symbolic state <tt>S</tt>, with result <tt>V</tt>. Because it is applied
  to symbolic states and symbolic calls, the result of the call must also be symbolic--
  in fact, <tt>V</tt> is the symbolic variable which will be set to the result
  of the call.</p>
  <p>For example, if the state were a list
  of pids, and <tt>COMMAND</tt> applied to <tt>Args</tt> spawned a new process,
  then the variable <tt>V</tt>
  could be added to the state to refer to the pid of the process just spawned.
  Symbolic function calls can also be included in the next state, to construct parts
  whose values will only be known during test execution.</p>
  <p>The same function is used to compute the next <i>dynamic</i> state during
  test execution. In this case <tt>S</tt> is the previous dynamic state,
  and <tt>Args</tt> are the actual values
  passed (not symbolic argument expressions), and <tt>V</tt> is the actual
  value returned--in other words, all the symbolic inputs are replaced by
  their values. A correctly written COMMAND_next function does not inspect
  symbolic inputs--it just includes them as symbolic parts of the result.
  Thus the same code can construct a dynamic state of the same shape,
  given actual values instead of symbolic ones. The only difficulty is that
  COMMAND_next may itself introduce symbolic function calls into its result,
  which would then be a kind of mixture of a symbolic and dynamic state.
  To ensure that the state remains dynamic during test execution, any
  such symbolic calls are performed, and replaced by their values,
  before test execution continues.</p>
  <b>default</b>: <tt>S</tt>, i.e., leave state unchanged
  </li>
  <li><h3>_next/4</h3><p>
  <tt>COMMAND_next(S::<a href="#type-symbolic_state"><code>symbolic_state()</code></a>, V::<a href="#type-var"><code>var()</code></a>, Args::[term()], MetaData::[proplists:property()]) :: <a href="#type-symbolic_state"><code>symbolic_state()</code></a></tt></p>
 
  <p>As <tt>_next/3</tt>,  but also taking <tt>MetaData</tt> into account.</p>
 
  Note: You may only use either <tt>COMMAND_next/3</tt> <b>or</b>
  <tt>COMMAND_next/4</tt>, not both!
  </li>
 
  <li><h3>_post/3</h3>
  <tt>COMMAND_post(S::<a href="#type-dynamic_state"><code>dynamic_state()</code></a>, Args::[term()], R::term()) :: bool()</tt>
  <p>Checks the postcondition of symbolic call <tt>{call, _, COMMAND, Args}</tt>, executed in <i>dynamic</i>
  state <tt>S</tt>, with result <tt>R</tt>.</p>
  <b>default</b>: true
  <p>Of course, postconditions are checked during test execution, not test
  generation.</p>
  </li>
 
  <li><h3>_post/4</h3>
  <tt>COMMAND_post(S::<a href="#type-dynamic_state"><code>dynamic_state()</code></a>, Args::[term()], R::term(), MetaData::[proplists:property()]) :: bool()</tt>
  <p>Checks the postcondition of symbolic call <tt>{call, _, COMMAND, Args}</tt>, executed in <i>dynamic</i>
  state <tt>S</tt>, with result <tt>R</tt>, having metadata <tt>MetaData</tt>.</p><p>
  <b>default</b>: true</p>
 
  <p>Note: You may only use either <tt>COMMAND_post/3</tt> <b>or</b>
  <tt>COMMAND_post/4</tt>, not both!</p>
 
  An important special case is checking that the result of <tt>COMMAND</tt> matches the
  expected return value. If <tt>COMMAND_return</tt> is specified this is done by:
  <pre>COMMAND_post(S, Args, Res) -&gt; eq(Res, COMMAND_return(S, Args)).</pre>
  </li>
 
  <li><h3>_return/2</h3>
  <tt>COMMAND_return(S::<a href="#type-symbolic_state"><code>symbolic_state()</code></a>, Args::[term()]) :: term()</tt>
  <p>This is an <i>optional</i> callback that computes the expected return value from the model state.
  This return value can be used in simulation mode, or when clustering a state machine with a component.
  It is often good practice to check the return value in the postcondition by explicitely calling this
  return callback to
  check whether the actual returned value is equivalent with the return value computed by this
  function using the model state.</p>
  <p>The return function can be an over specification, not leaving enough
  implementation freedom. In those cases it is preferred to use a
  general postcondition, which might check that
  the returned value is in a certain range or of a certain form.</p>
  </li>
  <li><h3>_return/3</h3><p>
  <tt>COMMAND_return(S::<a href="#type-symbolic_state"><code>symbolic_state()</code></a>, Args::[term()], MetaData::[proplists:property()]) :: term()</tt></p>
 
  <p>As <tt>_return/2</tt>, but also taking <tt>MetaData</tt> into account.</p>
 
  Note: You may only use either <tt>COMMAND_return/2</tt> <b>or</b>
  <tt>COMMAND_return/3</tt>, not both!
  </li>
 
  <li><h3>_features/3</h3>
  <tt>COMMAND_features(S::<a href="#type-dynamic_state"><code>dynamic_state()</code></a>, Args::[term()], R::term()) :: list(any())</tt>
  <p>Collects a list of features of the symbolic call <tt>{call, _, COMMAND, Args}</tt>, executed in <i>dynamic</i>
  state <tt>S</tt>, with result <tt>R</tt>.
  The arguments of the symbolic call  are the
  actual values passed, not any symbolic expressions from which they were computed.
  The features can be recovered later using <a href="#call_features-1"><code>call_features/1</code></a>.</p>
  <b>default</b>: []
  <p>Features are collected during test execution, not test
  generation.</p>
  </li>
 
  <li><h3>_dynamicpre/2</h3>
  <tt>dynamic_precondition(S::<a href="#type-dynamic_state"><code>dynamic_state()</code></a>, Args::[term()]) :: bool()</tt>
  <p>
  This is an <i>optional</i> call-back which can be used to check a
  precondition during test <i>execution</i>. Its argument is a
  dynamic state, and a call with the <i>actual</i> argument values
  (even for calls which are generated with symbolic arguments). If it
  returns <tt>false</tt>, then the command is not executed during the test.
 
  Dynamic preconditions may be easier to write than the normal
  preconditions, because they need not work with symbolic
  values. However, they have significant disadvantages:</p>
  <ul>
  <li>Because they cannot be tested during test case
  <i>generation</i>, then they lead to invalid test cases being
  generated which must be "patched up" during execution. This can
  affect both testing efficiency and test case distribution negatively.
  </li>
  <li>They cannot be used in parallel testing, so if a
  dynamic_precondition callback is used, then race condition testing
  with <a href="#parallel_commands-1"><code>parallel_commands/1</code></a> is not possible.
  </li>
  </ul>
 
  <p>For these reasons, it is almost always better to enrich the model
  state so that a static precondition can be defined, than to use a
  dynamic one. In rare cases, and especially when the dynamic
  precondition will usually be <tt>true</tt>, then using this
  call-back can be the best approach.</p>
  <b>default</b>: true
  </li>
  <li><h3>_dynamicpre/3</h3><p>
  <tt>COMMAND_dynamicpre(S::<a href="#type-dynamic_state"><code>dynamic_state()</code></a>, Args::[term()], MetaData::[proplists:property()]) :: bool()</tt></p>
 
  <p>As <tt>_dynamicpre/2</tt>, but also taking <tt>MetaData</tt> into account.</p>
 
  Note: You may only use either <tt>COMMAND_dynamicpre/2</tt> <b>or</b>
  <tt>COMMAND_dynamicpre/3</tt>, not both!
  </li>
  <li><a name="shape"/><h3>_shape/1</h3><p>
  <tt>COMMAND_shape(Args::[term()]) :: [<a href="#type-shape"><code>shape()</code></a>]</tt></p>
 
  This is an <i>optional</i> callback used in conjunction with <a href="#more_bugs-3"><code>more_bugs/3</code></a>. It describes how more_bugs should treat the arguments of the given
  command when generalising a command sequence. The default is
  <tt>[ ?VAR || _ &lt;- Args ]</tt> and means that more_bugs will consider it
  relevant whether two arguments (in the same or different commands) are
  equal, but not what the actual values are.
  </li>
  <li><h3>_shape/2</h3><p>
  <tt>COMMAND_shape(Args::[term()], MetaData::[proplists:property()]) :: [shape()]</tt></p>
 
  As <tt>_shape/1</tt>, but taking <tt>MetaData</tt> into account.
  </li>
  </ul>
  In addition to specific callbacks for one command, there are a few more
  general callbacks:
  <ul>
  <li><h3>weight/2</h3>
  <tt>weight(S::<a href="#type-dynamic_state"><code>dynamic_state()</code></a>, Cmd :: atom()) :: non_neg_integer()</tt>
  <p>
  This is an <i>optional</i> callback which
  specifies the distribution with which commands are generated. Commands are normally
  generated with a the <a href="eqc_gen.html#oneof-1">oneof</a> generator unless a weight function
  is provided. In this case the weight computed from the symbolic state <tt>S</tt> is
  used as frequency in the <a href="eqc_gen.html#frequency-1">frequency</a> generator (used instead
  of oneof).</p> </li>
 
  <li><h3>invariant/1</h3>
  <tt>invariant(S::<a href="#type-dynamic_state"><code>dynamic_state()</code></a>) :: bool()</tt>
  <p>
  This is an <i>optional</i> callback which can be used to check an
  invariant during test execution. It is called at the beginning of
  each command sequence with the initial state as argument, and then
  after each command is executed with the resulting state as
  argument. Its argument is always a <i>dynamic</i> state; it is not
  used during test case generation.  If <tt>invariant</tt> returns
  anything other than <tt>true</tt>, the test fails. Its intended use
  is to compare the model state <tt>S</tt> with the actual state of
  the system under test.
  </p><p>
  If <tt>invariant</tt> is not defined by the user, then it is assumed
  to be <tt>true</tt>.
  </p>
  </li>
 
  <li><h3>precondition_common/2</h3><p>
  <tt>precondition_common(S::<a href="#type-symbolic_state"><code>symbolic_state()</code></a>, Call::[call()]) :: bool()</tt></p>
 
  <p>Used to specify a general precondition. This precondition is applied after command
  generation, but <b>before</b> the specific (<tt>COMMAND_pre/2</tt> or
  <tt>COMMAND_pre/3</tt>) is applied. Thus in <tt>COMMAND_pre/2</tt> (or
  <tt>COMMAND_pre/3</tt>) one may assume that the general precondition holds.</p>
 
  </li>
  <li><h3>command_precondition_common/2</h3><p>
  <tt>command_precondition_common(S::<a href="#type-dynamic_state"><code>dynamic_state()</code></a>, COMMAND :: atom()) :: bool()</tt></p>
 
  A special case of a common precondition used to specify a general command filtering precondition
  <b>before</b> the arguments are generated.
  A typical usage is:
  <pre>command_precondition_common(S, Cmd) -&gt;
    S /= uninitialized orelse Cmd == init.</pre>
  This precondition ensures that unless the state is not <tt>uninitialized</tt> the
  command must be <tt>init</tt>.
  </li>
 
  <li><h3>postcondition_common/3</h3><p>
  <tt>postcondition_common(S::<a href="#type-symbolic_state"><code>symbolic_state()</code></a>, Call::[call()], Res::term()) :: bool()</tt></p>
 
  Used to specify a general postcondition. This precondition is applied <b>after</b> the
  specific (<tt>COMMAND_post/3</tt> or <tt>COMMAND_post/4</tt>) is applied. A typical
  usage for <a href="eqc_component.html"><code>eqc_component</code></a> is to check that all return values follow what we expect:
  <pre>postcondition_common(S, Call, Res) -&gt;
    eq(Res, return_value(S, Call)).</pre>
 
  </li>
  <li><h3>call_features_common/3</h3><p>
  <tt>call_features_common(S::<a href="#type-symbolic_state"><code>symbolic_state()</code></a>, Call::[call()], Res::term()) ::[any()]</tt></p>
 
  Used to specify features for all commands. These features are in
  addition to the features specified in specific
  <tt>COMMAND_features</tt> callbacks.
  </li>
 
  <li><h3>user_features/1</h3><p>
  <tt>user_features([any()]) :: [any()]</tt></p>
 
  This function defines a transformation over features. This can be
  used to filter features or group features together. If this callback is provided,
  the a property that contains <a href="#call_features-1"><code>call_features/1</code></a> can be replaced by
  <tt>call_features(user_features(H))</tt> to apply some pre-processing of
  the feature list.
  </li>
 
  </ul>
 
  <h3>What Property Should We Test?</h3>
  This module does <i>not</i> define any properties to test, it only provides
  functions to make defining such properties easy. A client module will
  normally contain a property resembling this one, which generates a
  command sequence using the client state machine, and then tests it:
  <pre>prop_statem_correct() -&gt;
    ?FORALL(Cmds, commands(client),
      begin {H, S, Res} = run_commands(Cmds),
            pretty_commands(client, Cmds, {H, S, Res},
                            Res == ok).
      end).</pre><p>  
However, in any particular case we may wish to add a little to this  
basic form, for example to collect statistics, to clean up after  
test execution, or to print more information in the event of failure.  
It is to allow this flexibility that the properties to test are  
placed in the client module, rather than in this one.</p>
 
  <h3>Parallel Testing</h3>
  Parallel test cases are generated using <a href="#parallel_commands-1"><code>parallel_commands/1</code></a>
  instead of <a href="#commands-1"><code>commands/1</code></a>. Instead of just one list of commands,
  a parallel test case consists of a sequential prefix, followed by a
  list of concurrent tasks. The prefix and each task are lists
  of commands, just like a sequential test case. A parallel test case
  is run using <a href="#run_parallel_commands-2"><code>run_parallel_commands/2</code></a>, by first executing the
  prefix in the normal way, then executing the concurrent tasks in
  newly spawned processes. The test passes if every command behaves
  <i>atomically</i>--that is, if the results we actually see could
  have been produced by some serialization of the concurrent
  tasks.
  <p>
  <i>Blocking</i> operations can be specified using the optional
  callback:</p>
  <ul>
  <li><h3>_blocking/2</h3><p>
  <tt>COMMAND_blocking(S::<a href="#type-dynamic_state"><code>dynamic_state()</code></a>, Args::[term()]) :: bool()</tt></p>
 
  <p>If <tt>blocking</tt> returns <tt>true</tt>, then QuickCheck assumes
  that the given call blocks in that state, allowing concurrent non-blocking
  calls to proceed first. Hopefully one of these will change the state
  so as to allow the blocking call to proceed. If not, QuickCheck
  expects the blocking call to <i>time out</i> eventually, allowing
  the test case to finish. Blocking operations can be included in test
  cases even if the <tt>COMMAND_blocking/2</tt> callback is not defined, but
  QuickCheck can find more bugs given the additional information that
  <tt>blocking</tt> represents. </p>
  <b>default</b>: <tt>false</tt>
  </li>
  </ul>
  <p>
  The properties for parallel testing are very similar to those for
  sequential testing: we just replace the <a href="#commands-1"><code>commands/1</code></a> and
  <a href="#run_commands-1"><code>run_commands/1</code></a> functions by their parallel versions. Often,
  though, the race conditions we are testing for only occur sometimes,
  and so we need to repeat each test several times using
  <b>?ALWAYS</b> to be reasonably sure of provoking it. It is only
  really necessary to do this during shrinking (since otherwise
  shrinking is likely to stop before the test case is properly
  simplified). Using this idea, a property that tests each case once
  while initially searching for a failure, then ten times at each
  shrinking step, could be written using the parameter shrinking as
  <pre>prop_atomic() -&gt;
    ?LET(Shrinking, parameter(shrinking, false),
      ?FORALL(ParCmds, parallel_commands(client),
        ?ALWAYS(if Shrinking -&gt; 10; true -&gt; 1 end,
          begin  {Seq, Par, Res} = run_parallel_commands(Cmds),
                  pretty_commands(?MODULE, Cmds, {Seq, Par, Res},
                                  Res == ok)
          end))).</pre>
  Note also that the results from <a href="#run_parallel_commands-2"><code>run_parallel_commands/2</code></a> are
  a little different from those of <a href="run_commands.html"><code>run_commands</code></a>.
  </p>
 
  <p>One difference to be aware of is that postconditions and
  invariants are not checked <i>during</i> a parallel test, they are
  checked <i>afterwards</i> using the results collected from the
  concurrent tasks. This means that the postcondition and invariant
  callbacks cannot inspect the <i>current state</i> of the software  
under test, when they are used in parallel testing.</p>
 
  <tt>linearizable(ParCmds)</tt> can be used to insert calls to
  <tt>now()</tt> into the generated test case, giving more information
  to be used when deciding whether tests passed or failed.
<h2><a name="types">Data Types</a></h2>

<h3 class="typedecl"><a name="type-bug">bug()</a></h3>
<p><tt>bug() = {[<a href="#type-generalised_commands">generalised_commands()</a>], <a href="eqc.html#type-counterexample">eqc:counterexample()</a>}</tt></p>
<p> A counterexample together with a generalisation of the counterexample
 commmand sequence. Returned by <a href="#more_bugs-3"><code>more_bugs/3</code></a>.</p>

<h3 class="typedecl"><a name="type-call">call()</a></h3>
<p><tt>call() = {call, module(), atom(), [<a href="#type-expr">expr()</a>]} | {call, module(), atom(), [<a href="#type-expr">expr()</a>], <a href="#type-metadata">metadata()</a>}</tt></p>
<p> A symbolic function call:
 {call, M, F, Args} represents a call of function F in module M, with arguments Args.
 {call, M, F, Args, Meta} represents a call with metadata (which may be symbolic).
 Metadata does not affect the way the call is executed, but is passed
 (as part of the call) to all the <tt>eqc_statem</tt> call-backs that
 take a call as an argument.</p>

<h3 class="typedecl"><a name="type-command">command()</a></h3>
<p><tt>command() = {model, module()} | {init, <a href="#type-symbolic_state">symbolic_state()</a>} | {set, <a href="#type-var">var()</a>, <a href="#type-call">call()</a>}</tt></p>
<p> A symbolic command, which when run either
 performs a call and binds the result to a variable, or initialises
 the state of the test case. (The latter appears only when <a href="#commands-2"><code>commands/2</code></a>
 in used to generate a command sequence starting in a state other than
 initial_state()).</p>

<h3 class="typedecl"><a name="type-dynamic_state">dynamic_state()</a></h3>
<p><tt>dynamic_state() = any()</tt></p>
<p> The type used by the client module to represent
 the state of a test case during test execution. It is the same as
 <a href="#type-symbolic_state"><code>symbolic_state()</code></a>, except that symbolic variables and calls
 are replaced by their values.</p>

<h3 class="typedecl"><a name="type-exit">exit()</a></h3>
<p><tt>exit() = {'EXIT', term()}</tt></p>
<p> The type of a caught exception.</p>

<h3 class="typedecl"><a name="type-expr">expr()</a></h3>
<p><tt>expr() = term()</tt></p>
<p> A symbolic expression, which is evaluated by
 replacing any symbolic variables (<a href="#type-var"><code>var()</code></a>) or function calls
 (<a href="#type-call"><code>call()</code></a>) in the term by their values.</p>

<h3 class="typedecl"><a name="type-generalised_commands">generalised_commands()</a></h3>
<p><b>abstract datatype</b>: <tt>generalised_commands()</tt></p>
<p> A generalised command sequence used by <a href="#more_bugs-3"><code>more_bugs/3</code></a> representing a set
 of command sequences that should be avoided during test case generation.</p>

<h3 class="typedecl"><a name="type-history">history()</a></h3>
<p><tt>history() = [<a href="#type-history_entry">history_entry()</a>]</tt></p>
<p> The history of a test execution, with one element for each command that was
 executed.</p>

<h3 class="typedecl"><a name="type-history_entry">history_entry()</a></h3>
<p><b>abstract datatype</b>: <tt>history_entry()</tt></p>
<p> A history entry storing information about the execution of a single command.</p>

<h3 class="typedecl"><a name="type-metadata">metadata()</a></h3>
<p><tt>metadata() = [{atom(), <a href="#type-expr">expr()</a>}]</tt></p>
<p> A property list, where each property is a tuple containing a tag and an expression.</p>

<h3 class="typedecl"><a name="type-parallel_test_case">parallel_test_case()</a></h3>
<p><tt>parallel_test_case() = {[<a href="#type-command">command()</a>], [[<a href="#type-command">command()</a>]]}</tt></p>
<p> A sequential prefix, and a list of concurrent child tasks.</p>

<h3 class="typedecl"><a name="type-reason">reason()</a></h3>
<p><tt>reason() = ok | initialization | {precondition, boolean()} | {postcondition, any()} | {invariant, any()} | {exception, <a href="#type-exit">exit()</a>} | precondition_failed | {bad_dynamic_precondition, term()} | {bad_next_state, term()} | {bad_precondition, term()}</tt></p>
<p> The reason execution of a command sequence terminated.
 <ul>
 <li>ok
 <p>All commands completed normally, and all postconditions were true.</p>
 </li>
 <li>initialization
 <p>There was an exception when computing the initial state--that is, converting the
 result of initial_state() to a <a href="#type-dynamic_state"><code>dynamic_state()</code></a>.</p></li>
 <li>precondition
 <p>A precondition failed to return <tt>true</tt> <i>during test execution</i>.
 Since preconditions are checked when tests are generated, this should not normally
 happen. It is possible
 when using <a href="eqc.html#check-2"><code>eqc:check/2</code></a> to rerun a saved test, after modifying the code,
 or if any of <tt>initial_state/0</tt>, a <tt>_next</tt> or
 <tt>_precondition</tt> callback behaves differently at generation time and test execution
 time. For example, a pattern match on a symbolic variable (<tt>{var, N}</tt>) will
 behave differently during test case generation and execution--so any such pattern
 matching is a warning sign.
 </p>
 </li>
 <li>postcondition
 <p>A postcondition failed to return <tt>true</tt>.</p></li>
 <li>invariant
 <p>An invariant failed to return <tt>true</tt>.</p></li>
 <li>exception
 <p>One of the commands in the sequence raised an exception. In this case the
 <a href="#type-history"><code>history()</code></a> contains all previous commands, and the final state is
 the state just before the faulty command was executed.</p></li>
 </ul></p>

<h3 class="typedecl"><a name="type-shape">shape()</a></h3>
<p><tt>shape() = '?VAR' | '_' | term()</tt></p>
<p> The shape of a command argument. Used by <a href="#more_bugs-3"><code>more_bugs/3</code></a> to generalise
 command sequences. If the shape is <tt>?VAR</tt> (as a macro, not an atom),
 the concrete value of the argument is not important, only whether it appears
 in other places in the command sequence. If the shape is '_' the argument is
 ignored completely by <tt>more_bugs</tt>. <tt>?VAR</tt> and '_' are allowed
 to appear as subterms of the shape.</p>

<h3 class="typedecl"><a name="type-symbolic_state">symbolic_state()</a></h3>
<p><tt>symbolic_state() = any()</tt></p>
<p> The type used by the client module to represent
 the state of a test case during test case generation.</p>

<h3 class="typedecl"><a name="type-var">var()</a></h3>
<p><tt>var() = {var, integer()}</tt></p>
<p> A symbolic variable, which is replace during test execution by the value bound
 by the corresponding <a href="#type-command"><code>command()</code></a>.</p>

<h2><a name="index">Function Index</a></h2>
<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#apply-3">apply/3</a></td><td>Added by the QuickCheck framework to recognize the origin of the apply in test sequences.</td></tr>
<tr><td valign="top"><a href="#call_features-1">call_features/1</a></td><td>Returns a list of command features exercised in this test.</td></tr>
<tr><td valign="top"><a href="#call_features-2">call_features/2</a></td><td>Returns a list of features exercised by calls to <tt>F</tt> (or
 <tt>F/A</tt>, if the arity is also specified).</td></tr>
<tr><td valign="top"><a href="#check_command_names-2">check_command_names/2</a></td><td>Print distribution of commands and fail if some commands have not been executed.</td></tr>
<tr><td valign="top"><a href="#command_names-1">command_names/1</a></td><td>Returns a list of the command names used in <tt>Cmds</tt>.</td></tr>
<tr><td valign="top"><a href="#commands-1">commands/1</a></td><td>Generates a list of commands, using the abstract state machine defined
 in module <tt>Mod</tt>.</td></tr>
<tr><td valign="top"><a href="#commands-2">commands/2</a></td><td>Behaves like <a href="#commands-1"><code>commands/1</code></a>, but generates a list of
 commands starting in state S.</td></tr>
<tr><td valign="top"><a href="#commands_length-1">commands_length/1</a></td><td>Returns the length of a command sequence <tt>Cmds</tt>.</td></tr>
<tr><td valign="top"><a href="#conj-1">conj/1</a></td><td>Conjoin a list of booleans, returning true if they are all
  true.</td></tr>
<tr><td valign="top"><a href="#eq-2">eq/2</a></td><td>Compare X and Y for equality, returns true if equal, and {X, '/=', Y}
  otherwise.</td></tr>
<tr><td valign="top"><a href="#get_metadata-2">get_metadata/2</a></td><td>Retreive a field from the MetaData component.</td></tr>
<tr><td valign="top"><a href="#history_command-1">history_command/1</a></td><td>Get the command from a history entry.</td></tr>
<tr><td valign="top"><a href="#history_features-1">history_features/1</a></td><td>Get the features from a history entry.</td></tr>
<tr><td valign="top"><a href="#history_result-1">history_result/1</a></td><td>Get the result of the command from a history entry.</td></tr>
<tr><td valign="top"><a href="#history_state-1">history_state/1</a></td><td>Get the state before the execution of the command from a history entry.</td></tr>
<tr><td valign="top"><a href="#linearizable-1">linearizable/1</a></td><td>Adds calls of eqc_statem:now() before and after each command
  in the parallel part of the test case, which enables us to
  <i>observe</i> the order in which calls are made.</td></tr>
<tr><td valign="top"><a href="#more_bugs-1">more_bugs/1</a></td><td>Test a state machine property repeatedly, avoiding already discovered
  bugs.</td></tr>
<tr><td valign="top"><a href="#more_bugs-2">more_bugs/2</a></td><td>Test a state machine property repeatedly, avoiding already discovered
  bugs.</td></tr>
<tr><td valign="top"><a href="#more_bugs-3">more_bugs/3</a></td><td>Test a state machine property repeatedly, to find up to
  <tt>N</tt> <i>different</i> bugs.</td></tr>
<tr><td valign="top"><a href="#more_commands-2">more_commands/2</a></td><td>Increases the expected length of command sequences generated within Gen by
 a factor N.</td></tr>
<tr><td valign="top"><a href="#now-0">now/0</a></td><td>Used in combination with <a href="#linearizable-1"><code>linearizable/1</code></a>.</td></tr>
<tr><td valign="top"><a href="#parallel_commands-1">parallel_commands/1</a></td><td>Generate a parallel test case from the callbacks in the client
  module <tt>Mod</tt>.</td></tr>
<tr><td valign="top"><a href="#parallel_commands-2">parallel_commands/2</a></td><td>Behaves like <a href="#parallel_commands-1"><code>parallel_commands/1</code></a>, but generates a test
  case starting in the state <tt>S</tt>.</td></tr>
<tr><td valign="top"><a href="#postconditions-2">postconditions/2</a></td><td>Given the values returned by a list of
 commands, checks that all pre- and postconditions are satisfied.</td></tr>
<tr><td valign="top"><a href="#pretty_commands-4">pretty_commands/4</a></td><td>Pretty-prints the execution history of a failing test, showing
  the calls made, the actual arguments and results, and (optionally)
  the model states.</td></tr>
<tr><td valign="top"><a href="#pretty_commands-5">pretty_commands/5</a></td><td>Like <a href="#pretty_commands-4"><code>pretty_commands/4</code></a>, but also takes the environment
  passed to <a href="#run_commands-2"><code>run_commands/2</code></a> as an additional parameter.</td></tr>
<tr><td valign="top"><a href="#print_bugs-1">print_bugs/1</a></td><td>Print generalised bugs returned by <a href="#more_bugs-4"><code>more_bugs/4</code></a> in a readable way.</td></tr>
<tr><td valign="top"><a href="#run_commands-1">run_commands/1</a></td><td>Runs a list of commands generated by some client module <tt>Mod</tt>.</td></tr>
<tr><td valign="top"><a href="#run_commands-2">run_commands/2</a></td><td>Behaves like <a href="#run_commands-1"><code>run_commands/1</code></a>, but also takes an environment
 containing values for additional variables that may be referred
 to in test cases.</td></tr>
<tr><td valign="top"><a href="#run_parallel_commands-1">run_parallel_commands/1</a></td><td>Runs a parallel test case, and returns the history of the
  prefix, each of the parallel tasks, and the overall result.</td></tr>
<tr><td valign="top"><a href="#run_parallel_commands-2">run_parallel_commands/2</a></td><td>Runs a parallel test case, but also takes an environment, like <a href="#run_commands-2"><code>run_commands/2</code></a>.</td></tr>
<tr><td valign="top"><a href="#show_states-1">show_states/1</a></td><td>Causes a call of <a href="#pretty_commands-4"><code>pretty_commands/4</code></a> or <a href="#pretty_commands-5"><code>pretty_commands/5</code></a> in the property to display the test case states
  as well as arguments and results.</td></tr>
<tr><td valign="top"><a href="#state_after-1">state_after/1</a></td><td>Returns the symbolic state after a list of commands is run.</td></tr>
<tr><td valign="top"><a href="#user_features-2">user_features/2</a></td><td>Modifier of features stored in <a href="#type-history"><code>history()</code></a> by applying
 the model callback <tt>Mod:user_features([feature()]) -&gt; [feature()]</tt>,
 if defined.</td></tr>
<tr><td valign="top"><a href="#zip-2">zip/2</a></td><td>Zips two lists together,
 but accepts lists of different lengths, stopping when the shorter
 list stops.</td></tr>
</table>

<h2><a name="functions">Function Details</a></h2>

<h3 class="function"><a name="apply-3">apply/3</a></h3>
<div class="spec">
<p><tt>apply(M, F, As) -&gt; any()</tt></p>
</div><p>Equivalent to <a href="erlang.html#apply-3"><tt>erlang:apply(M, F, As)</tt></a>.</p>
<p>Added by the QuickCheck framework to recognize the origin of the apply in test sequences.</p>

<h3 class="function"><a name="call_features-1">call_features/1</a></h3>
<div class="spec">
<p><tt>call_features(H::<a href="#type-history">history()</a>) -&gt; [any()]</tt><br/></p>
</div><p>Returns a list of command features exercised in this test.</p>

<h3 class="function"><a name="call_features-2">call_features/2</a></h3>
<div class="spec">
<p><tt>call_features(F::atom() | {atom(), <a href="#type-int">int()</a>}, H::<a href="#type-history">history()</a>) -&gt; [any()]</tt><br/></p>
</div><p>Returns a list of features exercised by calls to <tt>F</tt> (or
 <tt>F/A</tt>, if the arity is also specified).</p>

<h3 class="function"><a name="check_command_names-2">check_command_names/2</a></h3>
<div class="spec">
<p><tt>check_command_names(Cmds::[<a href="#type-command">command()</a>], Prop::<a href="#type-property">property()</a>) -&gt; <a href="#type-property">property()</a></tt><br/></p>
</div><p>Print distribution of commands and fail if some commands have not been executed.
  Requires a grouped style state machine. See <a href="eqc_group_commands.html"><code>eqc_group_commands</code></a>.</p>

<h3 class="function"><a name="command_names-1">command_names/1</a></h3>
<div class="spec">
<p><tt>command_names(Cmds::[<a href="#type-command">command()</a>]) -&gt; [{atom(), atom(), integer()}]</tt><br/></p>
</div><p>Returns a list of the command names used in <tt>Cmds</tt>. This
 function can be used in properties to measure the frequency with
 which each command actually occurs in the generated test cases, as follows:
 <pre>
 ?FORALL(Cmds, commands(...),
   begin
     {H, S, Res} = run_commands(Cmds),
     aggregate(command_names(Cmds),
               Res == ok)
   end)
 </pre></p>

<h3 class="function"><a name="commands-1">commands/1</a></h3>
<div class="spec">
<p><tt>commands(Mod::atom()) -&gt; <a href="#type-gen">gen</a>([<a href="#type-command">command()</a>])</tt><br/></p>
</div><p>Generates a list of commands, using the abstract state machine defined
 in module <tt>Mod</tt>. The commands in the sequence are generated by
 Mod:command/1, starting in the state Mod:initial_state(), and tracking
 state changes using Mod:next_state/3. Commands are only included in the
 sequence if their precondition (given by Mod:precondition/2) is satisfied.
 Sequences are shrunk by discarding commands in such a way that
 preconditions always hold, and all variables are set before they are used.</p>

<h3 class="function"><a name="commands-2">commands/2</a></h3>
<div class="spec">
<p><tt>commands(Mod::atom(), S::<a href="#type-symbolic_state">symbolic_state()</a>) -&gt; <a href="#type-gen">gen</a>([<a href="#type-command">command()</a>])</tt><br/></p>
</div><p>Behaves like <a href="#commands-1"><code>commands/1</code></a>, but generates a list of
 commands starting in state S. To ensure the correct state when the
 commands are run, an <tt>{init, S}</tt> command is added to the list.</p>

<h3 class="function"><a name="commands_length-1">commands_length/1</a></h3>
<div class="spec">
<p><tt>commands_length(Cmds::[<a href="#type-command">command()</a>]) -&gt; integer()</tt><br/></p>
</div><p>Returns the length of a command sequence <tt>Cmds</tt>. This
 function can be used in properties to measure the length of different
 generated command sequences, as follows:
 <pre>
 ?FORALL(Cmds, commands(...),
   begin
     {H, S, Res} = run_commands(Cmds),
     measure(length, commands_length(Cmds),
               Res == ok)
   end)
 </pre>
 For parallel command sequences it will add the sequential and parallel
 sequences, such that you get the total number of commands generated for that
 each test case.</p>

<h3 class="function"><a name="conj-1">conj/1</a></h3>
<div class="spec">
<p><tt>conj(Xs::[any()]) -&gt; any()</tt><br/></p>
</div><p>Conjoin a list of booleans, returning true if they are all
  true. If there are any non-true values in the argument, they are
  returned in the result. Typically used in postconditions, to return
  a more informative reason for test failure.</p>

<h3 class="function"><a name="eq-2">eq/2</a></h3>
<div class="spec">
<p><tt>eq(X, Y) -&gt; true | {X, '/=', Y}</tt>
<ul class="definitions"><li><tt>X = term()</tt></li><li><tt>Y = term()</tt></li></ul></p>
</div><p>Compare X and Y for equality, returns true if equal, and {X, '/=', Y}
  otherwise. Typically used in postcondition; since it will result in a more informative
  counterexample.</p>

<h3 class="function"><a name="get_metadata-2">get_metadata/2</a></h3>
<div class="spec">
<p><tt>get_metadata(Key::term(), Call::<a href="#type-call">call()</a>) -&gt; false | {ok, term()}</tt><br/></p>
</div><p>Retreive a field from the MetaData component. This function pre-suppose that the
  meta data is organized in the form of a proplist with {Key, Value}-pairs.</p>

<h3 class="function"><a name="history_command-1">history_command/1</a></h3>
<div class="spec">
<p><tt>history_command(Eqc_statem_history::<a href="#type-history_entry">history_entry()</a>) -&gt; <a href="#type-command">command()</a></tt><br/></p>
</div><p>Get the command from a history entry.</p>

<h3 class="function"><a name="history_features-1">history_features/1</a></h3>
<div class="spec">
<p><tt>history_features(Eqc_statem_history::<a href="#type-history_entry">history_entry()</a>) -&gt; [any()]</tt><br/></p>
</div><p>Get the features from a history entry.</p>

<h3 class="function"><a name="history_result-1">history_result/1</a></h3>
<div class="spec">
<p><tt>history_result(Eqc_statem_history::<a href="#type-history_entry">history_entry()</a>) -&gt; any()</tt><br/></p>
</div><p>Get the result of the command from a history entry.</p>

<h3 class="function"><a name="history_state-1">history_state/1</a></h3>
<div class="spec">
<p><tt>history_state(Eqc_statem_history::<a href="#type-history_entry">history_entry()</a>) -&gt; <a href="#type-dynamic_state">dynamic_state()</a></tt><br/></p>
</div><p>Get the state before the execution of the command from a history entry.</p>

<h3 class="function"><a name="linearizable-1">linearizable/1</a></h3>
<div class="spec">
<p><tt>linearizable(TestCase::<a href="#type-parallel_test_case">parallel_test_case()</a>) -&gt; <a href="#type-parallel_test_case">parallel_test_case()</a></tt><br/></p>
</div><p>Adds calls of eqc_statem:now() before and after each command
  in the parallel part of the test case, which enables us to
  <i>observe</i> the order in which calls are made. This gives us
  more information with which to determine whether a test passed or
  failed, which may improve the detection of races. On the other
  hand, calling now() involves a global synchronization, and so may
  make race conditions <i>less</i> likely to appear.</p>

<h3 class="function"><a name="more_bugs-1">more_bugs/1</a></h3>
<div class="spec">
<p><tt>more_bugs(Prop::<a href="eqc.html#type-property">eqc:property()</a>) -&gt; <a href="eqc_suite.html#type-test_suite">eqc_suite:test_suite()</a></tt><br/></p>
</div><p>Equivalent to <a href="#more_bugs-2"><tt>more_bugs(Prop, 20)</tt></a>.</p>
<p>Test a state machine property repeatedly, avoiding already discovered
  bugs.</p>

<h3 class="function"><a name="more_bugs-2">more_bugs/2</a></h3>
<div class="spec">
<p><tt>more_bugs(Prop::<a href="eqc.html#type-property">eqc:property()</a>, N::non_neg_integer() | infinity) -&gt; <a href="eqc_suite.html#type-test_suite">eqc_suite:test_suite()</a></tt><br/></p>
</div><p>Equivalent to <a href="#more_bugs-3"><tt>more_bugs(Prop, N, [])</tt></a>.</p>
<p>Test a state machine property repeatedly, avoiding already discovered
  bugs.</p>

<h3 class="function"><a name="more_bugs-3">more_bugs/3</a></h3>
<div class="spec">
<p><tt>more_bugs(Prop::<a href="eqc.html#type-property">eqc:property()</a>, N::non_neg_integer() | infinity, Bugs::<a href="eqc_suite.html#type-test_suite">eqc_suite:test_suite()</a>) -&gt; <a href="eqc_suite.html#type-test_suite">eqc_suite:test_suite()</a></tt><br/></p>
</div><p>Test a state machine property repeatedly, to find up to
  <tt>N</tt> <i>different</i> bugs. The arguments are
  <dl><dt><tt>Prop</tt></dt><dd> The property to test.
  </dd><dt><tt>N</tt></dt><dd> The maximum number of bugs to find
  before stopping.  </dd><dt><tt>Bugs</tt></dt><dd> Previously found
  bugs to avoid. This parameter should be the result of a previous
  call of <a href="#more_bugs-4"><code>more_bugs/4</code></a>; these bugs are then avoided, so <a href="#more_bugs-4"><code>more_bugs/4</code></a> searches for <i>other</i> bugs instead.  </dd></dl>
 
  <p><a href="#more_bugs-4"><code>more_bugs/4</code></a> keeps searching for more bugs until <tt>N</tt>
  bugs have been found, or the number of tests specified by <a href="eqc.html#numtests-2"><code>eqc:numtests/2</code></a> have been run with no failure, or the time limit
  specified by <a href="eqc.html#testing_time-2"><code>eqc:testing_time/2</code></a> has been reached. Time
  limits apply to the <i>total time</i> spent running <a href="#more_bugs-4"><code>more_bugs/4</code></a>, not the time spent searching for any individual bug.</p>
 
  <p>There are a few mechanisms that control when a command sequence is  
considered to be "the same" as a previously found bug: inclusion,  
reordering, and abstraction.</p>
 
  <h3>Inclusion</h3><p>
  A command sequence <tt>Cmds</tt> is considered an instance of a bug
  <tt>B</tt> if it contains all the commands (up to abstraction) of <tt>B</tt>
  in the same order. For example, the sequence <tt>[X, A, Y, B]</tt> is an
  instance of the bug <tt>[A, B]</tt>, but not of <tt>[Y, A]</tt>.</p>
 
  <h3>Reordering</h3><p>
  When a counterexample of the property is found, <tt>more_bugs</tt> tries to
  discover reorderings of the command sequence that also provoke the bug. The
  type <a href="#type-generalised_commands"><code>generalised_commands()</code></a> represents a set of reorderings of a
  command sequence using the primitive <tt>Cmd | GCmds</tt> (pronounced
  <tt>Cmd</tt> <em>anywhere in</em> <tt>GCmds</tt>) to represent all possible
  ways of inserting <tt>Cmd</tt> somewhere in the (generalised) command
  sequence <tt>GCmds</tt>. A command sequence is an instance of a bug if it is  
an instance of any of the reorderings it represents.</p>
 
  For example, the generalised sequence
  <pre>
  X | A
      B
      C
  </pre>
  represents the four sequences
  <pre>
  [X, A, B, C]
  [A, X, B, C]
  [A, B, X, C]
  [A, B, C, X]
  </pre>
 
  <h3>Abstraction</h3><p>
  In many cases the concrete values of the command arguments are not important
  for the behaviour of a system, only their identity. For example, the process
  registry does not care about which names you register processes under, but
  it does matter if you use the same name in different places (such as in a
  call to <tt>register</tt> followed by a call to <tt>whereis</tt>). To
  capture this, <tt>more_bugs</tt> treats command arguments as abstract
  variables, recording only whether two values are the same, but not their
  actual values. Thus, <tt>f(1), f(1)</tt> is considered the same bug as
  <tt>f(2), f(2)</tt>, but <tt>f(1), f(2)</tt> is not an instance of either  
(the former are instances of the latter though).</p>
 
  <p>To change this behaviour you can define a <a href="#shape">shape
  callback</a> for a given command. This returns a <a href="#type-shape"><code>shape()</code></a> for each
  argument of the command, where <tt>?VAR</tt> is the default behaviour and
  <tt>'_'</tt> means that <tt>more_bugs</tt> ignores the argument completely.  
If the concrete value is important the shape callback should return the  
actual value.</p>
 
  <h3>Example</h3>
  Typical use:
  <pre>
  prop_ok() -&gt;
    ?FORALL(Cmds, commands(?MODULE),
    begin
      HSR={_, _, Res} = run_commands(Cmds),
      pretty_commands(?MODULE, Cmds, HSR, Res == ok)
    end).
 
  bugs() -&gt; eqc_statem:more_bugs(prop_ok()).
  </pre>
 </p>

<h3 class="function"><a name="more_commands-2">more_commands/2</a></h3>
<div class="spec">
<p><tt>more_commands(N::<a href="#type-int">int()</a>, Gen::<a href="#type-gen">gen</a>(A)) -&gt; <a href="#type-gen">gen</a>(A)</tt><br/></p>
</div><p>Increases the expected length of command sequences generated within Gen by
 a factor N.</p>

<h3 class="function"><a name="now-0">now/0</a></h3>
<div class="spec">
<p><tt>now() -&gt; any()</tt></p>
</div><p>Equivalent to <a href="os.html#timestamp-0"><tt>os:timestamp()</tt></a>.</p>
<p>Used in combination with <a href="#linearizable-1"><code>linearizable/1</code></a>.</p>

<h3 class="function"><a name="parallel_commands-1">parallel_commands/1</a></h3>
<div class="spec">
<p><tt>parallel_commands(Mod::atom()) -&gt; <a href="#type-gen">gen</a>(<a href="#type-parallel_test_case">parallel_test_case()</a>)</tt><br/></p>
</div><p>Generate a parallel test case from the callbacks in the client
  module <tt>Mod</tt>. These test cases are used to test for race
  conditions that make the commands in the tests behave non-atomically.</p>

<h3 class="function"><a name="parallel_commands-2">parallel_commands/2</a></h3>
<div class="spec">
<p><tt>parallel_commands(Mod::atom(), S::<a href="#type-symbolic_state">symbolic_state()</a>) -&gt; <a href="#type-gen">gen</a>(<a href="#type-parallel_test_case">parallel_test_case()</a>)</tt><br/></p>
</div><p>Behaves like <a href="#parallel_commands-1"><code>parallel_commands/1</code></a>, but generates a test
  case starting in the state <tt>S</tt>.</p>

<h3 class="function"><a name="postconditions-2">postconditions/2</a></h3>
<div class="spec">
<p><tt>postconditions(Cmds::[<a href="#type-command">command()</a>], Vals::[term()]) -&gt; boolean()</tt><br/></p>
</div><p>Given the values returned by a list of
 commands, checks that all pre- and postconditions are satisfied. Mod
 is a module defining a state machine, Cmds a list of commands
 generated from it, and Vals the list of values returned by running
 those commands. This function is useful when the list of commands
 cannot be run just by calling <a href="#run_commands-1"><code>run_commands/1</code></a>, for example
 because the commands represent calls to functions in a different
 programming language.</p>

<h3 class="function"><a name="pretty_commands-4">pretty_commands/4</a></h3>
<div class="spec">
<p><tt>pretty_commands(Mod::atom(), Cmds::[<a href="#type-command">command()</a>], HSRes::{<a href="#type-history">history()</a>, <a href="#type-dynamic_state">dynamic_state()</a>, <a href="#type-reason">reason()</a>}, P::<a href="#type-property">property()</a>) -&gt; <a href="#type-property">property()</a></tt><br/></p>
</div><p>Pretty-prints the execution history of a failing test, showing
  the calls made, the actual arguments and results, and (optionally)
  the model states. Like <tt>?WHENFAIL</tt>, <a href="pretty_commands.html"><code>pretty_commands</code></a>
  takes the rest of the property as its last argument, and constructs
  a new property that also pretty-prints. The argument <tt>Cmds</tt>
  should be the list of commands passed to <a href="#run_commands-1"><code>run_commands/1</code></a>,
  and <tt>HSRes</tt> should be its result. Alternatively
  (notwithstanding the type signature above) a parallel test case
  generated by <a href="#parallel_commands-1"><code>parallel_commands/1</code></a>, and the result of
  <a href="#run_parallel_commands-1"><code>run_parallel_commands/1</code></a>, can be passed instead.
  <p>
  The pretty-printing can be customized using
  <a href="eqc_gen.html#with_parameter-3"><code>eqc_gen:with_parameter/3</code></a> to specify
  <ul>
  <li><tt>show_states</tt> (<tt>true</tt> or <tt>false</tt>), to
  determine whether model states should be included in the output, </li>
  <li><tt>pretty_width</tt> (an integer), to specify the width
  available for pretty-printing.</li>
  </ul>
  Note that these parameters are parameters to the entire property,
  and can be specified when <a href="eqc.html#quickcheck-1"><code>eqc:quickcheck/1</code></a> is called from the Erlang shell.</p>
  <p>Alternatively, the simplest way to show the states when a property fails is to call
  <pre>
  eqc:quickcheck(eqc_statem:show_states(...property...)).
  </pre>
  from the shell.</p></p>

<h3 class="function"><a name="pretty_commands-5">pretty_commands/5</a></h3>
<div class="spec">
<p><tt>pretty_commands(Mod::atom(), Cmds::[<a href="#type-command">command()</a>], HSRes::{<a href="#type-history">history()</a>, <a href="#type-dynamic_state">dynamic_state()</a>, <a href="#type-reason">reason()</a>}, Env::[{atom(), term()}], P::<a href="#type-property">property()</a>) -&gt; <a href="#type-property">property()</a></tt><br/></p>
</div><p>Like <a href="#pretty_commands-4"><code>pretty_commands/4</code></a>, but also takes the environment
  passed to <a href="#run_commands-2"><code>run_commands/2</code></a> as an additional parameter.</p>

<h3 class="function"><a name="print_bugs-1">print_bugs/1</a></h3>
<div class="spec">
<p><tt>print_bugs(X1::<a href="eqc_suite.html#type-test_suite">eqc_suite:test_suite()</a>) -&gt; ok</tt><br/></p>
</div><p>Print generalised bugs returned by <a href="#more_bugs-4"><code>more_bugs/4</code></a> in a readable way.</p>

<h3 class="function"><a name="run_commands-1">run_commands/1</a></h3>
<div class="spec">
<p><tt>run_commands(Cmds::[<a href="#type-command">command()</a>]) -&gt; {<a href="#type-history">history()</a>, <a href="#type-dynamic_state">dynamic_state()</a>, <a href="#type-reason">reason()</a>}</tt><br/></p>
</div><p>Runs a list of commands generated by some client module <tt>Mod</tt>.
 Before each command is run, its precondition is checked by
 <tt>Mod:precondition/2</tt>, and after each command is executed, its postcondition is
 checked by <tt>Mod:postcondition/3</tt>. The result contains the <a href="#type-history"><code>history()</code></a> of
 execution, the state after the last command that was executed successfully,
 and the <a href="#type-reason"><code>reason()</code></a> execution stopped.
 <p>
 <b>Note:</b> Command sequences generated with QuickCheck &lt; 1.39 do not
 contain the name of the client module and must be run with <a href="#run_commands-2"><code>run_commands/2</code></a>. </p></p>

<h3 class="function"><a name="run_commands-2">run_commands/2</a></h3>
<div class="spec">
<p><tt>run_commands(Cmds::[<a href="#type-command">command()</a>], Env::[{atom(), term()}]) -&gt; {<a href="#type-history">history()</a>, <a href="#type-dynamic_state">dynamic_state()</a>, <a href="#type-reason">reason()</a>}</tt><br/></p>
</div><p>Behaves like <a href="#run_commands-1"><code>run_commands/1</code></a>, but also takes an environment
 containing values for additional variables that may be referred
 to in test cases. For example, if <tt>Env</tt> is <tt>[{x, 32}]</tt>,
 then <tt>{var, x}</tt> may appear in the commands, and will evaluate
 to 32. The variables names must be atoms (unlike generated variable
 names, which are numbers).
 <p><b>Note:</b>
 For command sequences generated by QuickCheck &lt; 1.39 you can also use this
 function as <tt>run_commands(Mod, Cmds)</tt> to specify the client module
 that generated the command sequence.
 </p></p>

<h3 class="function"><a name="run_parallel_commands-1">run_parallel_commands/1</a></h3>
<div class="spec">
<p><tt>run_parallel_commands(Cmds::<a href="#type-parallel_test_case">parallel_test_case()</a>) -&gt; {<a href="#type-history">history()</a>, [<a href="#type-history">history()</a>], <a href="#type-reason">reason()</a>}</tt><br/></p>
</div><p>Runs a parallel test case, and returns the history of the
  prefix, each of the parallel tasks, and the overall result.</p>

<h3 class="function"><a name="run_parallel_commands-2">run_parallel_commands/2</a></h3>
<div class="spec">
<p><tt>run_parallel_commands(Cmds::<a href="#type-parallel_test_case">parallel_test_case()</a>, E::[{atom(), term()}]) -&gt; {<a href="#type-history">history()</a>, [<a href="#type-history">history()</a>], <a href="#type-reason">reason()</a>}</tt><br/></p>
</div><p>Runs a parallel test case, but also takes an environment, like <a href="#run_commands-2"><code>run_commands/2</code></a>.</p>

<h3 class="function"><a name="show_states-1">show_states/1</a></h3>
<div class="spec">
<p><tt>show_states(Prop::<a href="#type-property">property()</a>) -&gt; <a href="#type-property">property()</a></tt><br/></p>
</div><p>Causes a call of <a href="#pretty_commands-4"><code>pretty_commands/4</code></a> or <a href="#pretty_commands-5"><code>pretty_commands/5</code></a> in the property to display the test case states
  as well as arguments and results.</p>

<h3 class="function"><a name="state_after-1">state_after/1</a></h3>
<div class="spec">
<p><tt>state_after(Cmds::[<a href="#type-command">command()</a>]) -&gt; <a href="#type-symbolic_state">symbolic_state()</a></tt><br/></p>
</div><p>Returns the symbolic state after a list of commands is run. The
 commands are not executed.</p>

<h3 class="function"><a name="user_features-2">user_features/2</a></h3>
<div class="spec">
<p><tt>user_features(Mod::module(), H::<a href="#type-history">history()</a>) -&gt; <a href="#type-history">history()</a></tt><br/></p>
</div><p>Modifier of features stored in <a href="#type-history"><code>history()</code></a> by applying
 the model callback <tt>Mod:user_features([feature()]) -&gt; [feature()]</tt>,
 if defined.</p>

<h3 class="function"><a name="zip-2">zip/2</a></h3>
<div class="spec">
<p><tt>zip(Xs::[A], Ys::[B]) -&gt; [{A, B}]</tt><br/></p>
</div><p>Zips two lists together,
 but accepts lists of different lengths, stopping when the shorter
 list stops. This is useful to zip together a list of commands with
 the history returned by <a href="#run_commands-1"><code>run_commands/1</code></a>, to display each
 command together with its result in the output from QuickCheck.</p>
<hr/>

<div class="navbar"><a name="#navbar_bottom"/><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"/></a></td></tr></table></div>
<p><i>Generated by EDoc, Jun 13 2017, 10:20:28.</i></p>
</body>
</html>
